# RFM98W Library
William Eustaceâ€“Team Impulse

_This library is made available under the MIT licence; please see the repository root._

## Notes: please read
The object of this library is to permit easy control of a Hope RF RFM98W radio module (which uses the rather
impressive LoRa modulation to extend range beyond what would normally be plausible in this frequency band and at this power level) from an Arduino, or similar microcontroller (it has been used extensively by Team Impulse on the Teensy 3.1).

These modules are 434MHz; although it has not been tested, I see no reason why this code should not work for
any Semtech SX1276 based system, since the interface (over SPI) is broadly standard. Some areas might need tweaking.

Bandwidths down to 7.8kHz are achievable, but not with the RFM98W, since this has an ordinary crystal oscillator rather than
the required Temperature-Compensated Crystal Oscillator (TCXO). If the crystal is towards the edge of the specified frequency,
the centre frequency is too far off to be received with a smaller bandwidth. In other words, lower
bandwidth operations are infeasible (20.8kHz works on some modules but not others, and below this has not
been successfully tested) without a more accurate crystal or a TCXO. This has caused me a lot of grief
during the development of the library, until it was determined to be the issue! If you require 31.25kHz or 20.8kHz bandwidths on the RFM98W, David Shah suggests you set the final config register (```RegModemConfig3```) to 0x08; he has helpfully added this functionality to the library.

This system has been successfully tested for High Altitude Balloon (HAB) flight, with range significantly exceeding 100km laterally. Line of sight is the limit, rather than distance; the high link budget suggests that if you can 'see' the balloon, it would be surprising in the extreme if you could not receive packets from it. It has also been successfully tested on a high-power rocket launch (European CanSat competition) to 3200 feet (1000m).

During my testing, I found that the PA_BOOST output gives far better RSSI than the RFO output pin (despite being selected to a power output of 10mW, well within the capabilities of the RFO output). I am unsure of the reason for this, and it may be that it was a software error on my part, but I would suggest using the PA_BOOST pin, although some careful experimentation would not go amiss (I don't currently have time to fiddle around with the settings, since the Team Impulse CanSat project has been concluded). This is controlled from the config register ```RegPAConfig```, as described below.

The I/O pins which must be connected to the microcontroller are as follows: SPI pins (MOSI, MISO, SCK) and DIO0. The rest are optional and unused by this library; you may wish to use the RESET line, depending on your application.

## Usage
Please see examples for general set-up and necessary includes. The following commands are somewhat ambiguous and clarified below:
* ```RFMLib radio =RFMLib(20,7,16,21);```
(the initial object instantiation) has the pin numbers as its arguments, as follows: ```byte nss, byte dio0, byte dio5, byte rfm_rst```. If you are not using DIO5 or RESET, pass in 255 instead of a pin number and no issue will arise; they were included in the function purely in case a need arose for them, but it has not done so to date. Neither RESET nor DIO5 are actually used from the library.

* ```byte my_config[6] = {0x44,0x84,0x88,0xAC,0xCD,0x08};
  radio.configure(my_config);```

  The 6 ```my_config``` bytes are as follows: ```{RegModemConfig1, RegModemConfig2, RegPAConfig, NA, NA,RegModemConfig3}```
These are generated by hand with reference to the datasheet (readily available online). I would suggest selecting the PA_BOOST output amplifier rather than the RFO one, but experimentation is worthwhile (see above). Hopefully the ```radio.configure(my_config);``` line is fairly self-explanatory! Note the bytes marked `NA` are not actually used for anything, and are for historical purposes only.

Setting ```RegModemConfig3``` to 0x08 enables the low data rate optimiser, which is supposed to improve performance at low bandwiths/high spreading factors by compensating to some extent for oscillator drift - without it 31.25kHz and 20.8kHz are very unreliable. If you want to use high data rates, you can turn this off by setting the register to 0x00.

Finally set the frequency using

 * `radio.setFrequency(869525000)` to set the frequency to 869.525MHz, or any other frequency in Hz.

If you require assistance with the use of this library, please feel free to email the address provided on my GitHub profile.
